# 刷题笔记

## 一、时间连续问题

### 1.1、通过按日期进行排序获取新的日期进行分组

```
1、过滤掉同一天重复记录
2、通过窗口对每个用户ID下的时间进行逆向排序
3、将时间与排序后的序号相加得到一个新的日期
4、对用户ID和新的日期进行分组，并求得每组数据数量
5、对数量进行筛选，数量是几就是连续几天
```

![image-20230705102947625](C:\Users\liwei\AppData\Roaming\Typora\typora-user-images\image-20230705102947625.png)

### 1.2、通过计算与前一天的日期的时间间隔

```
1、使用窗口函数按日期进行排序，获取前一个日期
2、计算当前日期与前一个日期的时间间隔，若间隔等于0则为一天多次登录情况，若间隔等于1则连续，否则不连续
3、使用窗口函数，计算窗口中从第一行到当前行的间隔之和
4、对间隔之和进行分组，并求每组数据数量
5、对数量进行筛选，数量是几就是连续几天
```

```sql
-- 创建测试数据
WITH data AS (
    SELECT 'a' AS type, '小明' AS name, DATE '2023-01-01' AS start_date, DATE '2023-01-03' AS end_date UNION ALL
    SELECT 'a' AS type, '小明' AS name, DATE '2023-01-04' AS start_date, DATE '2023-01-07' AS end_date UNION ALL
    SELECT 'b' AS type, '小明' AS name, DATE '2023-01-08' AS start_date, DATE '2023-01-12' AS end_date UNION ALL
    SELECT 'b' AS type, '小明' AS name, DATE '2023-01-13' AS start_date, DATE '2023-01-16' AS end_date UNION ALL
    SELECT 'a' AS type, '小明' AS name, DATE '2023-01-17' AS start_date, DATE '2023-01-20' AS end_date
),
-- 将当前的开始日期与上一行的结束日期进行对比，若相等或相差一天则为连续，否则为不连续
data1 AS (
SELECT TYPE, name, start_date, END_date,
	CASE WHEN lag(end_date, 1) over(PARTITION BY name ORDER BY start_date) = date_add(start_date, INTERVAL -1 day)
	AND lag(TYPE, 1) over(PARTITION BY name ORDER BY start_date) = TYPE
	THEN 0
	ELSE 1
	END is_new_group
FROM DATA
),
-- 计算分组中从开始行到当前行的连续标识和
data2 AS (
	SELECT type, name, start_date, END_date,
	sum(is_new_group) over(PARTITION BY name ORDER BY start_date) group_id
	FROM data1
)
-- 若这个标识和连续不变则连续，若值增大则不连续。若要统计连续则按照这个标识进行分组
SELECT TYPE, name, min(start_date), max(END_date)
FROM data2
GROUP BY TYPE, name, GROUP_id;
```

### 1.3、中间间隔1天也为连续的连续问题

```
1、首先需要去重一天多次登录的情况
2、使用窗口函数按照id进行分组，login_date进行排序，获取前一行的日期
3、计算当前日期与前一次登录的日期的差值（若差值小于等于2则满足间隔1天也为连续的条件，赋值为0，其余情况赋值为1）
4、按照id进行分组，login_date进行排序，使用窗口函数计算窗口第一行到当前行的3中计算值的和，此值作为分组条件。若是差值不满足条件则此值加1，打破连续，否则此值不变
5、按照id和4中计算的值进行分组，分别获取分组中login_date的最大值和最小值，他们的差值即为连续天数。
6、最后需要过滤掉连续天数为0的数据
```

```sql
WITH DATA AS (
	SELECT '1' AS ID, '2022-01-02' AS LOGIN_DATE UNION ALL
	SELECT '2' AS ID, '2022-01-02' AS LOGIN_DATE UNION ALL
	SELECT '3' AS ID, '2022-01-02' AS LOGIN_DATE UNION ALL
	SELECT '3' AS ID, '2022-01-02' AS LOGIN_DATE UNION ALL
	SELECT '2' AS ID, '2022-01-02' AS LOGIN_DATE UNION ALL
	SELECT '2' AS ID, '2022-01-03' AS LOGIN_DATE UNION ALL
	SELECT '1' AS ID, '2022-01-04' AS LOGIN_DATE UNION ALL
	SELECT '3' AS ID, '2022-01-06' AS LOGIN_DATE UNION ALL
	SELECT '1' AS ID, '2022-01-05' AS LOGIN_DATE UNION ALL
	SELECT '2' AS ID, '2022-01-05' AS LOGIN_DATE UNION ALL
	SELECT '2' AS ID, '2022-01-06' AS LOGIN_DATE UNION ALL
	SELECT '3' AS ID, '2022-01-08' AS LOGIN_DATE UNION ALL
	SELECT '3' AS ID, '2022-01-09' AS LOGIN_DATE UNION ALL
	SELECT '2' AS ID, '2022-01-08' AS LOGIN_DATE UNION ALL
	SELECT '2' AS ID, '2022-01-07' AS LOGIN_DATE UNION ALL
	SELECT '1' AS ID, '2022-01-07' AS LOGIN_DATE
),
data2 AS (
SELECT id, login_date, lag(login_date, 1, '1970-01-01') over(PARTITION BY id ORDER BY login_date) LAG_date
FROM (
	SELECT DISTINCT id, login_date FROM data
) t
),
DATA3 AS (
SELECT id, login_date, lag_date, datediff(login_date, lag_date),
CASE WHEN datediff(login_date, lag_date) <= 2 THEN 0 ELSE 1 END AS FLAG
FROM data2
),
data4 AS (
SELECT id, login_date, lag_date, sum(flag) over(PARTITION BY id ORDER BY login_date) GROUP_id
FROM data3
)
SELECT id,
	max(login_date),
	min(login_date),
	datediff(max(login_date), min(login_date)) 
FROM data4
GROUP BY id, group_id
HAVING datediff(max(login_date), min(login_date)) > 0;
```

## 二、波峰波谷问题

```
波峰：当前值大于前一天和后一天的值
波谷：当前值小于前一天和后一天的值
1、获取前一天和后一天的值
2、当前值与前一天和后一天的值进行对比
```

```sql
-- 求出股票波峰波谷
WITH DATA AS (
	SELECT '1' AS ID, '2019-01-01' AS DS, 10001 AS PRICE UNION ALL
	SELECT '1' AS ID, '2019-01-02' AS DS, 1001 AS PRICE UNION ALL
	SELECT '1' AS ID, '2019-01-03' AS DS, 10002 AS PRICE UNION ALL
	SELECT '1' AS ID, '2019-01-04' AS DS, 999 AS PRICE UNION ALL
	SELECT '1' AS ID, '2019-01-05' AS DS, 10002 AS PRICE UNION ALL
	SELECT '1' AS ID, '2019-01-06' AS DS, 10003 AS PRICE UNION ALL
	SELECT '1' AS ID, '2019-01-07' AS DS, 10004 AS PRICE UNION ALL
	SELECT '1' AS ID, '2019-01-08' AS DS, 998 AS PRICE UNION ALL
	SELECT '1' AS ID, '2019-01-09' AS DS, 997 AS PRICE UNION ALL
	SELECT '1' AS ID, '2019-01-10' AS DS, 996 AS PRICE UNION ALL
	SELECT '2' AS ID, '2019-01-01' AS DS, 10001 AS PRICE UNION ALL
	SELECT '2' AS ID, '2019-01-02' AS DS, 10002 AS PRICE UNION ALL
	SELECT '2' AS ID, '2019-01-03' AS DS, 10003 AS PRICE UNION ALL
	SELECT '2' AS ID, '2019-01-04' AS DS, 10002 AS PRICE UNION ALL
	SELECT '2' AS ID, '2019-01-05' AS DS, 1002 AS PRICE UNION ALL
	SELECT '2' AS ID, '2019-01-06' AS DS, 1003 AS PRICE UNION ALL
	SELECT '2' AS ID, '2019-01-07' AS DS, 1004 AS PRICE UNION ALL
	SELECT '2' AS ID, '2019-01-08' AS DS, 998 AS PRICE UNION ALL
	SELECT '2' AS ID, '2019-01-09' AS DS, 997 AS PRICE UNION ALL
	SELECT '2' AS ID, '2019-01-10' AS DS, 996 AS PRICE
),
DATA2 AS (
SELECT
ID, PRICE,
LAG(PRICE,1) OVER(PARTITION BY ID ORDER BY DS) LAG_PRICE,
LEAD(PRICE, 1) OVER(PARTITION BY ID ORDER BY DS) LEAD_PRICE
FROM DATA
)
SELECT 
ID, LAG_PRICE, PRICE, LEAD_PRICE,
CASE WHEN PRICE > LAG_PRICE AND PRICE > LEAD_PRICE THEN '波峰'
WHEN PRICE < LAG_PRICE AND PRICE < LEAD_PRICE THEN '波谷'
END AS TYPE
FROM DATA2;
```

## 三、窗口函数

```
last_value/first_value:
参数：last_value(col, 是否忽略null) over()
```

```sql
 WITH DATA AS (
	SELECT '1' AS ID, '2023-01-02' AS DS, '1' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-03' AS DS, '1' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-04' AS DS, '0' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-05' AS DS, '0' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-06' AS DS, '1' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-07' AS DS, '0' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-08' AS DS, '1' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-09' AS DS, '1' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-10' AS DS, '0' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-11' AS DS, '0' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-12' AS DS, '0' AS IS_OPEN UNION ALL
	SELECT '1' AS ID, '2023-01-13' AS DS, '0' AS IS_OPEN
)
SELECT ID, DS, IS_OPEN,
COALESCE(LAST_VALUE(IF(IS_OPEN='1', DS, NULL), true) OVER(PARTITION BY ID ORDER BY DS ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING),'1970-01-01') PRE_DATE,
COALESCE(FIRST_VALUE(IF(IS_OPEN='1', DS, NULL), true) OVER(PARTITION BY ID ORDER BY DS ROWS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING), '2999-01-01') NEXT_DATE
FROM DATA;
```

## 四、TopN问题

```sql
-- 每个学生成绩第二高的科目
WITH DATA AS (
	SELECT 'a' AS class, 'yuxing' AS student, 100 AS score UNION ALL
	SELECT 'c' AS class, 'yuxing1' AS student, 60 AS score UNION ALL
	SELECT 'b' AS class, 'yuxing' AS student, 80 AS score UNION ALL
	SELECT 'b' AS class, 'yuxing1' AS student, 80 AS score UNION ALL
	SELECT 'c' AS class, 'yuxing' AS student, 90 AS score UNION ALL
	SELECT 'c' AS class, 'yuxing2' AS student, 90 AS score
)
SELECT
class,
student
FROM (
SELECT class, student,
dense_rank() over(PARTITION BY student ORDER BY score) rn
FROM data
) t
WHERE rn = 2;
```

```SQL
-- 统计每个用户累计访问次数
WITH DATA AS (
	SELECT 'U01' AS ID, '2017-01-21' AS DT, 5 AS CNT UNION ALL
	SELECT 'U02' AS ID, '2017-01-23' AS DT, 6 AS CNT UNION ALL
	SELECT 'U03' AS ID, '2017-01-22' AS DT, 8 AS CNT UNION ALL
	SELECT 'U04' AS ID, '2017-01-20' AS DT, 3 AS CNT UNION ALL
	SELECT 'U01' AS ID, '2017-01-23' AS DT, 6 AS CNT UNION ALL
	SELECT 'U01' AS ID, '2017-02-21' AS DT, 8 AS CNT UNION ALL
	SELECT 'U02' AS ID, '2017-01-23' AS DT, 6 AS CNT UNION ALL
	SELECT 'U01' AS ID, '2017-02-22' AS DT, 4 AS CNT
),
data2 AS (
SELECT ID, SUBSTR(DT, 0, 7) `MONTH`,
sum(cnt) cnt
FROM data
GROUP BY id, SUBSTR(DT, 0, 7)
)
SELECT ID, `MONTH`, CNT,
SUM(CNT) OVER(PARTITION BY ID ORDER BY `MONTH` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) LEIJI_CNT
FROM DATA2
ORDER BY ID, `MONTH`;
```

## 五、同时在线问题

```
1、对登录的打标签1，登出的打标签-1，使用union all将两种数据连接起来
2、使用sum over()计算同一时间在线人数
3、分组，求的最大在线人数
```

## 六、炸裂函数

```
explode(数组/map)：将数组或map拆分为一行一行的数据
posexplode(数组)：将数组拆分为一行一行的数据，带索引，索引从0开始
```

```sql
WITH DATA AS (
	SELECT '广东省' AS PROVICE, '南方、经济强省' AS CATEGORY UNION ALL
	SELECT '海南省' AS PROVICE, '热带、旅游、自由贸易' AS CATEGORY UNION ALL
	SELECT '新疆' AS PROVICE, '西北、沙漠、哈密瓜' AS CATEGORY
),
DATA1 AS (
SELECT PROVICE, TYPE FROM DATA lateral VIEW
EXPLODE(SPLIT(CATEGORY, '、')) TBL AS TYPE
)
SELECT
PROVICE, pos, value
FROM DATA LATERAL VIEW
POSEXPLODE(SPLIT(CATEGORY, '、')) AS pos, value;
```

```sql
-- 使用posexplode填补缺失日期
WITH DATA AS (
	SELECT 'AAAA' AS CONTRACT, '2018-12-21' AS VALUE_DATE, 9439.30 AS AMOUNT, 12 AS TERM UNION ALL
	SELECT 'AAAA' AS CONTRACT, '2019-03-21' AS VALUE_DATE, 9439.30 AS AMOUNT, 12 AS TERM UNION ALL
	SELECT 'AAAA' AS CONTRACT, '2019-06-21' AS VALUE_DATE, 9439.30 AS AMOUNT, 12 AS TERM UNION ALL
	SELECT 'AAAA' AS CONTRACT, '2019-09-21' AS VALUE_DATE, 9439.30 AS AMOUNT, 12 AS TERM UNION ALL
	SELECT 'BBBB' AS CONTRACT, '2018-12-02' AS VALUE_DATE, 9439.30 AS AMOUNT, 10 AS TERM UNION ALL
	SELECT 'BBBB' AS CONTRACT, '2019-02-02' AS VALUE_DATE, 9439.30 AS AMOUNT, 10 AS TERM UNION ALL
	SELECT 'BBBB' AS CONTRACT, '2019-06-02' AS VALUE_DATE, 9439.30 AS AMOUNT, 10 AS TERM UNION ALL
	SELECT 'BBBB' AS CONTRACT, '2019-09-02' AS VALUE_DATE, 9439.30 AS AMOUNT, 10 AS TERM
)
SELECT
	CONTRACT, VALUE_DATE, ADD_MONTHS(VALUE_DATE, POS) VALUE_DATE, TERM, POS
FROM (
SELECT CONTRACT, MIN(VALUE_DATE) VALUE_DATE, MAX(AMOUNT) AMOUNT, MAX(TERM) TERM
FROM DATA
GROUP BY CONTRACT
) T1 LATERAL VIEW POSEXPLODE(SPLIT(SPACE(TERM), '(?!$)')) TMP AS POS, VAL
```

## 七、共同好友（相互关注）问题

```sql
-- 若是源表中未带日期，则一个人关注另一个人最多只能存储一条记录，则可以将关注者与被关注者拼接为数组，并且将数组进行排序，这样，若是共同好友则拼接的数组值一致。最后只需要对这个数组进行分组，count值大于1则为相互关注
-- 相互关注（共同好友）
WITH DATA AS (
	SELECT 'A' AS FROM_USER, 'B' AS TO_USER UNION ALL
	SELECT 'A' AS FROM_USER, 'C' AS TO_USER UNION ALL
	SELECT 'A' AS FROM_USER, 'D' AS TO_USER UNION ALL
	SELECT 'B' AS FROM_USER, 'A' AS TO_USER UNION ALL
	SELECT 'B' AS FROM_USER, 'E' AS TO_USER UNION ALL
	SELECT 'C' AS FROM_USER, 'A' AS TO_USER
)
SELECT
GROUP_LIST, COUNT(*)
FROM (
SELECT
FROM_USER, TO_USER,
sort_array(split(CONCAT_WS(',', FROM_USER, TO_USER),',')) GROUP_LIST
FROM DATA
) T
GROUP BY GROUP_LIST
HAVING COUNT(1) > 1
```

```sql
-- 相互关注（共同好友）存在多次关注（取消又关注）
-- 使用关联，你的关注是我，我的关注是你
WITH DATA AS (
	SELECT 'A' AS FROM_USER, 'B' AS TO_USER, '2022-01-02' AS DT UNION ALL
	SELECT 'A' AS FROM_USER, 'C' AS TO_USER, '2022-01-03' AS DT  UNION ALL
	SELECT 'A' AS FROM_USER, 'D' AS TO_USER, '2022-01-04' AS DT  UNION ALL
	SELECT 'B' AS FROM_USER, 'A' AS TO_USER, '2022-01-05' AS DT  UNION ALL
	SELECT 'B' AS FROM_USER, 'E' AS TO_USER, '2022-01-06' AS DT  UNION ALL
	SELECT 'C' AS FROM_USER, 'A' AS TO_USER, '2022-01-07' AS DT 
)
SELECT 
DISTINCT 
sort_array(split(concat_ws(',',T1.FROM_USER,T1.TO_USER), ','))
FROM DATA T1
JOIN DATA T2
ON T1.FROM_USER = T2.TO_USER
AND T1.TO_USER = T2.FROM_USER;
```

## 八、留存问题

```markdown
留存概念  
电商业务中需要计算用户留存情况，在时间维度上可以分为用户次日、多日后的留存情况，用留存率表示。留存率计算方式如下：  
1、次日留存率 = 当日新用户在次日登录的数量 / 当日新用户注册数量  
2、三日留存率 = 当日新用户在第四天登录的数量 / 当日新用户注册数量  
3、七日留存率 = 当日新用户在第八天登录的数量 / 当日新用户注册数量

步骤：
1、首先获取用户登录的最小日期，该日期为注册日期
2、其次使用lead函数获取每次登录日期后的下一次登录日期，并计算当次登录日期与下一次登录日期之间的差值
3、过滤数据，只保留当前日期等于注册日期的记录
4、通过对注册日期列进行分组，使用count(distinct col)计算每天新用户数量
5、通过对注册日期列进行分组，计算差值列为1的记录数量，即为新用户次日登录的数量
6、通过将次日登录数量除以当日新注册的用户数量可得到次日留存率
```

```sql
--1、次日留存率 = 当日新用户在次日登录的数量 / 当日新用户注册数量  
--2、三日留存率 = 当日新用户在第四天登录的数量 / 当日新用户注册数量  
--3、七日留存率 = 当日新用户在第八天登录的数量 / 当日新用户注册数量
WITH DATA AS (
select 0 as id,1 as uid, '2020-01-02 00:02:00' as login_time union all  
select 1 as id,2 as uid, '2020-01-02 00:02:00' as login_time union all  
select 2 as id,3 as uid, '2020-01-02 00:02:00' as login_time union all  
select 3 as id,1 as uid, '2020-01-03 00:02:00' as login_time union all  
select 4 as id,3 as uid, '2020-01-03 00:02:00' as login_time union all 
select 3 as id,1 as uid, '2020-01-03 00:02:10' as login_time union all
select 5 as id,4 as uid, '2020-01-03 00:02:00' as login_time union all  
select 6 as id,6 as uid, '2020-01-03 00:02:00' as login_time union all  
select 7 as id,2 as uid, '2020-01-04 00:02:00' as login_time union all  
select 8 as id,3 as uid, '2020-01-04 00:02:00' as login_time union all  
select 9 as id,5 as uid, '2020-01-04 00:02:00' as login_time union all  
select 10 as id,6 as uid, '2020-01-04 00:02:00' as login_time union all  
select 11 as id,7 as uid, '2020-01-04 00:02:00' as login_time union all  
select 12 as id,9 as uid, '2020-01-04 00:02:00' as login_time union all  
select 13 as id,1 as uid, '2020-01-05 00:02:00' as login_time union all  
select 14 as id,6 as uid, '2020-01-05 00:02:00' as login_time union all  
select 15 as id,7 as uid, '2020-01-05 00:02:00' as login_time union all  
select 16 as id,9 as uid, '2020-01-05 00:02:00' as login_time union all  
select 17 as id,10 as uid, '2020-01-05 00:02:00' as login_timE union all  
select 18 as id,11 as uid, '2020-01-05 00:02:00' as login_timE union all  
select 19 as id,4 as uid, '2020-01-06 00:02:00' as login_time union all  
select 20 as id,11 as uid, '2020-01-06 00:02:00' as login_timE union all  
select 21 as id,12 as uid, '2020-01-06 00:02:00' as login_timE union all  
select 22 as id,1 as uid, '2020-01-07 00:02:00' as login_time union all  
select 23 as id,2 as uid, '2020-01-07 00:02:00' as login_time union all  
select 24 as id,6 as uid, '2020-01-07 00:02:00' as login_time union all  
select 25 as id,8 as uid, '2020-01-07 00:02:00' as login_time union all  
select 26 as id,9 as uid, '2020-01-07 00:02:00' as login_time union all  
select 27 as id,2 as uid, '2020-01-08 00:02:00' as login_time union all  
select 28 as id,10 as uid, '2020-01-08 00:02:00' as login_timE union all  
select 29 as id,12 as uid, '2020-01-08 00:02:00' as login_timE union all  
select 30 as id,3 as uid, '2020-01-09 00:02:00' as login_time union all  
select 31 as id,8 as uid, '2020-01-09 00:02:00' as login_time union all  
select 32 as id,9 as uid, '2020-01-09 00:02:00' as login_time union all  
select 33 as id,11 as uid, '2020-01-09 00:02:00' as login_timE union all  
select 34 as id,4 as uid, '2020-01-10 00:02:00' as login_time union all  
select 35 as id,6 as uid, '2020-01-10 00:02:00' as login_time union all  
select 36 as id,7 as uid, '2020-01-10 00:02:00' as login_time union all  
select 37 as id,9 as uid, '2020-01-10 00:02:00' as login_time union all  
select 38 as id,10 as uid, '2020-01-10 00:02:00' as login_timE union all  
select 39 as id,12 as uid, '2020-01-10 00:02:00' as login_timE union all  
select 40 as id,6 as uid, '2020-01-11 00:02:00' as login_time union all  
select 41 as id,12 as uid, '2020-01-11 00:02:00' as login_time 
)
-- 当日新用户min_dt = dt
-- 当日新用户在次日登录 min_dt = dt, diff = 1
SELECT
T1.MIN_DT,
ROUND((SUM(IF(DATEDIFF(T2.DT, T1.MIN_DT)=1, 1, 0))/COUNT(DISTINCT T1.UID)) * 100, 2) || '%' AS '次日留存',
ROUND((SUM(IF(DATEDIFF(T2.DT, T1.MIN_DT)=3, 1, 0))/COUNT(DISTINCT T1.UID)) * 100, 2) || '%' AS '三日留存',
ROUND((SUM(IF(DATEDIFF(T2.DT, T1.MIN_DT)=7, 1, 0))/COUNT(DISTINCT T1.UID)) * 100, 2) || '%' AS '七日留存'
FROM (
SELECT
UID,
TO_DATE(MIN(LOGIN_TIME)) MIN_DT
FROM DATA
GROUP BY UID
) T1
JOIN (
	SELECT
	UID,
	TO_DATE(LOGIN_TIME) DT
	FROM DATA
	GROUP BY UID, TO_DATE(LOGIN_TIME)
) T2
ON T1.UID = T2.UID
GROUP BY T1.MIN_DT
ORDER BY T1.MIN_DT;
```

## 九、数据展开

```
1、使用explode将行转换成列
2、计算出每个缺口中的最小值，以及最小值和最大值之间的差值
3、按照差值大小使用peate函数将最小值按照某个间隔符（例如，）复制差值份
4、使用posexplode将3中的值炸裂开，并且将索引与值进行相加，即可得到补全后的值
5、之后使用collect_list将列转换成list，并且使用concat_ws将list转换成string
```



```sql
WITH DATA AS (
	SELECT '1-5,16,11-13,9' A 
)
SELECT
concat_ws(',', COLLECT_LIST(CAST(CAST((K+V) AS INT) AS String)))
FROM (
SELECT
SUBSTR(REPEAT(NUM||',', CAST(DIFF AS INT)), 0, LENGTH(REPEAT(NUM||',', CAST(DIFF AS INT)))-1) STR
FROM (
SELECT
T1.ARR[0] NUM, (t1.arr[size(t1.arr)-1] - t1.arr[0]) + 1 diff
FROM (
SELECT  
NUM, SPLIT(NUM, '-') ARR
FROM DATA
LATERAL VIEW EXPLODE(SPLIT(A, '[,]')) TBL AS NUM
)
T1
) T2
) T3
LATERAL VIEW POSEXPLODE(SPLIT(STR, ',')) TBL AS K, V
```

